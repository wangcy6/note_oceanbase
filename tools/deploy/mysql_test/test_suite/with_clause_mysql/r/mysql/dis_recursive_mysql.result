drop database if exists cte_st;
create database cte_st;
use cte_st;
result_format: 4
create table disemp (
  EMPno  number,
  ENAME varchar(30),
  JOB varchar(30) ,
  MGR number(4),
  HIREDATE date,
  SAL number(7,2),
  COMM number(7,2),
  DEPTNO number(2)
);

INSERT INTO disemp values (7369,'SMITH','CLERK',7902,    str_to_date('1980-11-17','%Y-%m-%d'),800,NULL, 20) ;
INSERT INTO disemp VALUES (7499, 'ALLEN','SALESMAN',7698,str_to_date('1981-01-20','%Y-%m-%d'),1600,300,30) ;
INSERT INTO disemp VALUES (7521,'WARD','SALESMAN',7698,  str_to_date('1981-01-22','%Y-%m-%d'),1250, 500, 30) ;
INSERT INTO disemp VALUES (7566,'JONES','MANAGER',7839,  str_to_date('1981-04-02','%Y-%m-%d'), 2975, NULL, 20) ;
INSERT INTO disemp VALUES (7654,'MARTIN','SALESMAN', 7698, str_to_date('1981-09-28','%Y-%m-%d'), 1250, 1400, 30) ;
INSERT INTO disemp VALUES (7698, 'BLAKE','MANAGER', 7839,  str_to_date('1981-03-01','%Y-%m-%d'), 2850, NULL, 30) ;
INSERT INTO disemp VALUES (7782, 'CLARK','MANAGER', 7839,  str_to_date('1981-06-09','%Y-%m-%d'), 2450, NULL, 10) ;
insert into disemp values (7788,'SCOTT','ANALYST', 7566,   str_to_date('1987-04-19','%Y-%m-%d'), 3000, null, 20) ;
INSERT INTO disemp VALUES (7839, 'KING','PRESIDENT', NULL, str_to_date('1981-11-17','%Y-%m-%d'), 5000, NULL, 10) ;
INSERT INTO disemp VALUES (7844, 'TURNER','SALESMAN', 7698, str_to_date('1981-09-08','%Y-%m-%d'), 1500, 0, 30) ;
INSERT INTO disemp VALUES(7876, 'ADAMS','CLERK', 7788,     str_to_date('1987-05-23','%Y-%m-%d'), 1100, NULL, 20) ;
INSERT INTO disemp VALUES(7900, 'JAMES', 'CLEARK', 7698,   str_to_date('1981-11-03','%Y-%m-%d'), 950, NULL, 30) ;
INSERT INTO disemp VALUES(7902, 'FORD','ANALYST',7566,     str_to_date('1981-11-03','%Y-%m-%d'), 3000, NULL, 20) ;
INSERT INTO disemp VALUES(7934,'MILLER','CLERK', 7782,     str_to_date('1982-01-23','%Y-%m-%d'), 1300,NULL, 10) ;

create table EMP (
  EMPno  number,
  ENAME varchar(30),
  JOB varchar(30),
  MGR number(4),
  HIREDATE date,
  SAL number(7,2),
  COMM number(7,2),
  DEPTNO number(2)
);

insert into EMP values (7369,'SMITH','CLERK',7902,    str_to_date('1980-12-17','%Y-%m-%d'),800,NULL, 20) ;
INSERT INTO EMP VALUES (7499, 'ALLEN','SALESMAN',7698,str_to_date('1981-02-20','%Y-%m-%d'),1600,300,30) ;
INSERT INTO EMP VALUES (7521,'WARD','SALESMAN',7698,  str_to_date('1981-02-22','%Y-%m-%d'),1250, 500, 30) ;
INSERT INTO EMP VALUES (7566,'JONES','MANAGER',7839,  str_to_date('1981-08-02','%Y-%m-%d'), 2975, NULL, 20) ;
INSERT INTO EMP VALUES (7654,'MARTIN','SALESMAN', 7698, str_to_date('1981-09-28','%Y-%m-%d'), 1250, 1400, 30) ;
INSERT INTO EMP VALUES (7698, 'BLAKE','MANAGER', 7839,  str_to_date('1981-05-01','%Y-%m-%d'), 2850, NULL, 30) ;
INSERT INTO EMP VALUES (7782, 'CLARK','MANAGER', 7839,  str_to_date('1981-06-09','%Y-%m-%d'), 2450, NULL, 10) ;
insert into EMP values (7788,'SCOTT','ANALYST', 7566,   str_to_date('1987-08-19','%Y-%m-%d'), 3000, null, 20) ;
INSERT INTO EMP VALUES (7839, 'KING','PRESIDENT', NULL, str_to_date('1981-11-17','%Y-%m-%d'), 5000, NULL, 10) ;
INSERT INTO EMP VALUES (7844, 'TURNER','SALESMAN', 7698, str_to_date('1981-09-08','%Y-%m-%d'), 1500, 0, 30) ;
INSERT INTO EMP VALUES(7876, 'ADAMS','CLERK', 7788,     str_to_date('1987-05-23','%Y-%m-%d'), 1100, NULL, 20) ;
INSERT INTO EMP VALUES(7900, 'JAMES', 'CLEARK', 7698,   str_to_date('1981-12-03','%Y-%m-%d'), 950, NULL, 30) ;
INSERT INTO EMP VALUES(7902, 'FORD','ANALYST',7566,     str_to_date('1981-12-03','%Y-%m-%d'), 3000, NULL, 20) ;
INSERT INTO EMP VALUES(7934,'MILLER','CLERK', 7782,     str_to_date('1982-06-23','%Y-%m-%d'), 1300,NULL, 10) ;

CREATE TABLE emp1 (
  empno    VARCHAR(4000) NOT NULL,
  ename    VARCHAR(14),
  job      VARCHAR(9),
  mgr      VARCHAR(4000),
  hiredate DATE,
  sal      NUMBER(7,2),
  comm     NUMBER(7,2),
  deptno   NUMBER(2));

INSERT INTO emp1 values (7369, 'SMITH', 'CLERK', 7902, str_to_date('1980-12-17', '%Y-%m-%d'), 800, null, 20);
INSERT INTO emp1 values (7499, 'ALLEN', 'SALESMAN', 7698, str_to_date('1981-02-20', '%Y-%m-%d'), 1600, 300, 30);
INSERT INTO emp1 values (7521, 'WARD', 'SALESMAN', 7698, str_to_date('1981-02-22', '%Y-%m-%d'), 1250, 500, 30);
INSERT INTO emp1 values (7566, 'JONES', 'MANAGER', 7839, str_to_date('1981-08-02', '%Y-%m-%d'), 2975, null, 20);
INSERT INTO emp1 values (7654, 'MARTIN', 'SALESMAN', 7698, str_to_date('1981-09-28', '%Y-%m-%d'), 1250, 1400, 30);
INSERT INTO emp1 values (7698, 'BLAKE', 'MANAGER', 7839, str_to_date('1981-05-01', '%Y-%m-%d'), 2850, null, 30);
INSERT INTO emp1 values (7782, 'CLARK', 'MANAGER', 7839, str_to_date('1981-06-09' , '%Y-%m-%d'), 2450, null, 10);
INSERT INTO emp1 values (7788, 'SCOTT', 'ANALYST', 7566, str_to_date('1987-08-19', '%Y-%m-%d'), 3000, null, 20);
INSERT INTO emp1 values (7839, 'KING', 'PRESIDENT', null, str_to_date('1981-11-17', '%Y-%m-%d'), 5000, null, 10);
INSERT INTO emp1 values (7844, 'TURNER', 'SALESMAN', 7698, str_to_date('1981-09-08', '%Y-%m-%d'), 1500, 0, 30);
INSERT INTO emp1 values (7876, 'ADAMS', 'CLERK', 7788, str_to_date('1987-05-23', '%Y-%m-%d'), 1100, null, 20);
INSERT INTO emp1 values (7900, 'JAMES', 'CLERK', 7698, str_to_date('1981-12-03', '%Y-%m-%d'), 950, null, 30);
INSERT INTO emp1 values (7902, 'FORD', 'ANALYST', 7566, str_to_date('1981-12-03', '%Y-%m-%d'), 3000, null, 20);
INSERT INTO emp1 values (7934, 'MILLER', 'CLERK', 7782, str_to_date('1982-01-23', '%Y-%m-%d'), 1300, null, 10);
INSERT INTO emp1 values (8100, 'Eve', 'MANAGER', 7839, str_to_date('1984-05-01', '%Y-%m-%d'), 2850, null, 30);
INSERT INTO emp1 values (8101, 'Eve1', 'MANAGER', 8100, str_to_date('1984-05-01','%Y-%m-%d'), 2850, null, 30);
INSERT INTO emp1 values (8108, 'Eve8', 'CLERK', 8101, str_to_date('1984-05-01', '%Y-%m-%d'), 2850, null, 30);

create table dsemp (id int, name varchar(20), leaderid int) partition by hash (id) partitions 3;
insert into dsemp values(1, 'A', '0');
insert into dsemp values(2, 'AA', '1');
insert into dsemp values(3, 'AB', '1');
insert into dsemp values(4, 'ABA', '3');
insert into dsemp values(5, 'AAA', '2');
insert into dsemp values(6, 'ABB', '3');
insert into dsemp values(7, 'AAA', '5');
insert into dsemp values(8, 'AAA', '7');
insert into dsemp values(9, 'AAAA', '5');
insert into dsemp values(10, 'AAAB', '5');
insert into dsemp values(11, 'AAAC', '5');
insert into dsemp values(12, 'AAAA', '5');

create table dsemp1 (id int, name varchar(20), leaderid int) partition by hash (leaderid) partitions 3;
insert into dsemp1 values(1, 'A', '0');
insert into dsemp1 values(2, 'AA', '1');
insert into dsemp1 values(3, 'AB', '1');
insert into dsemp1 values(4, 'ABA', '3');
insert into dsemp1 values(5, 'AAA', '2');
insert into dsemp1 values(6, 'ABB', '3');
insert into dsemp1 values(7, 'AAA', '5');
insert into dsemp1 values(8, 'AAA', '7');
insert into dsemp1 values(9, 'AAAA', '5');
insert into dsemp1 values(10, 'AAAB', '5');
insert into dsemp1 values(11, 'AAAC', '5');
insert into dsemp1 values(12, 'AAAA', '5');

result_format: 4

##############################
##   section 1  聚合一张表是分布式表（disemp）
##   section 2  聚合的两表是分布式表（disemp，emp1）
##   section 3  聚合的两表在join条件上可能形成wise join（disemp，emp1）
##   section 4  额外添加recursive member变化
##############################

##############################
##   section 1  聚合一张表是分布式表（disemp）
##############################
## =======================================================================
## Test Case 1:
## - recursive with RECURSIVE Query: Nested Loop Join
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_NL(r e) */  e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=======================================================
|ID|OPERATOR               |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------------
|0 |SUBPLAN SCAN           |rw  |433     |68          |
|1 |└─RECURSIVE UNION ALL  |    |433     |67          |
|2 |  ├─TABLE FULL SCAN    |e   |1       |3           |
|3 |  └─NESTED-LOOP JOIN   |    |432     |64          |
|4 |    ├─TABLE FULL SCAN  |r   |199     |1           |
|5 |    └─MATERIAL         |    |14      |5           |
|6 |      └─TABLE FULL SCAN|e   |14      |3           |
=======================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      conds([r.empno = e.MGR]), nl_params_(nil), use_batch=false
  4 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
  5 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
  6 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_NL(r e) */  e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| JONES  |  7566 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| SCOTT  |  7788 | 7566 |
| FORD   |  7902 | 7566 |
| ALLEN  |  7499 | 7698 |
| WARD   |  7521 | 7698 |
| MARTIN |  7654 | 7698 |
| TURNER |  7844 | 7698 |
| JAMES  |  7900 | 7698 |
| MILLER |  7934 | 7782 |
| ADAMS  |  7876 | 7788 |
| SMITH  |  7369 | 7902 |
+--------+-------+------+

## =======================================================================
## Test Case 2:
## - recursive with RECURSIVE Query: SORT MERGE Join
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_MERGE(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=========================================================
|ID|OPERATOR                 |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |SUBPLAN SCAN             |rw  |433     |137         |
|1 |└─RECURSIVE UNION ALL    |    |433     |135         |
|2 |  ├─TABLE FULL SCAN      |e   |1       |3           |
|3 |  └─MERGE JOIN           |    |432     |132         |
|4 |    │ MATERIAL           |    |14      |7           |
|5 |    └─│ SORT             |    |14      |5           |
|6 |      │ └─TABLE FULL SCAN|e   |14      |3           |
|7 |      SORT               |    |199     |107         |
|8 |      └─TABLE FULL SCAN  |r   |199     |1           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
      merge_directions([ASC])
  4 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
<<<<<<< HEAD
  5 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256, sort_keys([e.MGR, ASC])
  6 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256,
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
  7 - output([r.empno]), filter(nil), rowset=256, sort_keys([r.empno, ASC])
  8 - output([r.empno]), filter(nil), rowset=256,
      access([r.empno]), partitions is NULL,

=======
  5 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      sort_keys([e.MGR, ASC])
  6 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  7 - output([r.empno]), filter(nil), rowset=256
      sort_keys([r.empno, ASC])
  8 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
>>>>>>> 529367cd9b5b9b1ee0672ddeef2a9930fe7b95fe

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_MERGE(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| JONES  |  7566 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| SCOTT  |  7788 | 7566 |
| FORD   |  7902 | 7566 |
| ALLEN  |  7499 | 7698 |
| WARD   |  7521 | 7698 |
| MARTIN |  7654 | 7698 |
| TURNER |  7844 | 7698 |
| JAMES  |  7900 | 7698 |
| MILLER |  7934 | 7782 |
| ADAMS  |  7876 | 7788 |
| SMITH  |  7369 | 7902 |
+--------+-------+------+

## =======================================================================
## Test Case 3:
## - recursive with RECURSIVE Query: Hash Join
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |433     |30          |
|1 |└─RECURSIVE UNION ALL|    |433     |29          |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |432     |26          |
|4 |    ├─TABLE FULL SCAN|e   |14      |3           |
|5 |    └─TABLE FULL SCAN|r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 4:
## - recursive with RECURSIVE Query: Join in Initialisation Branch
## 与oracle的结果顺序不一样
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT /*+ USE_NL(e d) */ e.ename, e.mgr, e.empno
    FROM disemp e, disemp d 
    WHERE e.sal = d. sal
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e, disemp d
    WHERE r.empno = e.mgr and e.sal = d.sal
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=========================================================
|ID|OPERATOR                 |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |SUBPLAN SCAN             |rw  |520     |46          |
|1 |└─RECURSIVE UNION ALL    |    |520     |44          |
|2 |  ├─NESTED-LOOP JOIN     |    |17      |9           |
|3 |  │ ├─TABLE FULL SCAN    |e   |14      |3           |
|4 |  │ └─MATERIAL           |    |14      |3           |
|5 |  │   └─TABLE FULL SCAN  |d   |14      |3           |
|6 |  └─HASH JOIN            |    |504     |34          |
|7 |    │ MATERIAL           |    |17      |11          |
|8 |    └─│ HASH JOIN        |    |17      |9           |
|9 |      │ ├─TABLE FULL SCAN|d   |14      |3           |
|10|      │ └─TABLE FULL SCAN|e   |14      |3           |
|11|      TABLE FULL SCAN    |r   |199     |1           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      conds([e.SAL = d.SAL]), nl_params_(nil), use_batch=false
  3 - output([e.SAL], [e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      access([e.SAL], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  4 - output([d.SAL]), filter(nil), rowset=256
  5 - output([d.SAL]), filter(nil), rowset=256
      access([d.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([d.__pk_increment]), range(MIN ; MAX)always true
  6 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  7 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
  8 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([e.SAL = d.SAL]), other_conds(nil)
  9 - output([d.SAL]), filter(nil), rowset=256
      access([d.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([d.__pk_increment]), range(MIN ; MAX)always true
 10 - output([e.MGR], [e.SAL], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.SAL], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 11 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT /*+ USE_NL(e d) */ e.ename, e.mgr, e.empno
    FROM disemp e, disemp d 
    WHERE e.sal = d. sal
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e, disemp d
    WHERE r.empno = e.mgr and e.sal = d.sal
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ALLEN  |  7499 | 7698 |
| ALLEN  |  7499 | 7698 |
| ALLEN  |  7499 | 7698 |
| BLAKE  |  7698 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| CLARK  |  7782 | 7839 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| JAMES  |  7900 | 7698 |
| JAMES  |  7900 | 7698 |
| JAMES  |  7900 | 7698 |
| JONES  |  7566 | 7839 |
| JONES  |  7566 | 7839 |
| KING   |  7839 | NULL |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MILLER |  7934 | 7782 |
| MILLER |  7934 | 7782 |
| MILLER |  7934 | 7782 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| TURNER |  7844 | 7698 |
| TURNER |  7844 | 7698 |
| TURNER |  7844 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
+--------+-------+------+

## =======================================================================
## Test Case 6:
## - recursive with RECURSIVE Query: Hash Join without using hints
##                         Static input on build side and fits in memory
## 与oracle顺序不一致
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM disemp e, rw r
    WHERE e.mgr = r.empno 
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |433     |30          |
|1 |└─RECURSIVE UNION ALL|    |433     |29          |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |432     |26          |
|4 |    ├─TABLE FULL SCAN|e   |14      |3           |
|5 |    └─TABLE FULL SCAN|r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([e.MGR = r.empno]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM disemp e, rw r
    WHERE e.mgr = r.empno 
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 7:
## - recursive with RECURSIVE Query: Hash Join without using hints
##                         Static input on probe side and fits in memory
## =======================================================================
explain  
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |433     |30          |
|1 |└─RECURSIVE UNION ALL|    |433     |29          |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |432     |26          |
|4 |    ├─TABLE FULL SCAN|e   |14      |3           |
|5 |    └─TABLE FULL SCAN|r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## 测试8-15都是在测试join的顺序或者hint的顺序
## Test Case 8:
## - recursive with RECURSIVE Query: Join Order tests 
##                         pump >< disemp >< emp1 
## =======================================================================
explain  
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, disemp e, emp1 n
  WHERE r.mgr = e.empno and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
=========================================================
|ID|OPERATOR                 |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |SORT                     |    |1001    |501         |
|1 |└─SUBPLAN SCAN           |rw  |1001    |195         |
|2 |  └─RECURSIVE UNION ALL  |    |1001    |192         |
|3 |    ├─HASH JOIN          |    |79      |16          |
|4 |    │ ├─HASH JOIN        |    |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN|e   |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN|n1  |17      |3           |
|7 |    │ └─TABLE FULL SCAN  |n2  |17      |3           |
|8 |    └─HASH JOIN          |    |922     |175         |
|9 |      ├─HASH JOIN        |    |199     |112         |
|10|      │ ├─TABLE FULL SCAN|r   |199     |1           |
|11|      │ └─TABLE FULL SCAN|e   |5       |3           |
|12|      └─TABLE FULL SCAN  |n   |17      |3           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n.empno, DECIMAL(-1, -1))]), other_conds(nil)
  9 - output([r.empno], [e.MGR], [r.iters], [r.sal], [e.SAL]), filter(nil), rowset=256
      equal_conds([r.mgr = e.EMPno]), other_conds(nil)
 10 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 11 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, disemp e, emp1 n
  WHERE r.mgr = e.empno and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 9:
## - recursive with RECURSIVE Query: Join Order tests 
##                         disemp >< pump >< emp1 
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, rw r, emp1 n
  WHERE e.empno = r.mgr and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
=========================================================
|ID|OPERATOR                 |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |SORT                     |    |1001    |413         |
|1 |└─SUBPLAN SCAN           |rw  |1001    |107         |
|2 |  └─RECURSIVE UNION ALL  |    |1001    |104         |
|3 |    ├─HASH JOIN          |    |79      |16          |
|4 |    │ ├─HASH JOIN        |    |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN|e   |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN|n1  |17      |3           |
|7 |    │ └─TABLE FULL SCAN  |n2  |17      |3           |
|8 |    └─HASH JOIN          |    |922     |86          |
|9 |      ├─HASH JOIN        |    |199     |23          |
|10|      │ ├─TABLE FULL SCAN|e   |5       |3           |
|11|      │ └─TABLE FULL SCAN|r   |199     |1           |
|12|      └─TABLE FULL SCAN  |n   |17      |3           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n.empno, DECIMAL(-1, -1))]), other_conds(nil)
  9 - output([r.empno], [e.MGR], [e.SAL], [r.iters], [r.sal]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
 10 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 11 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, rw r, emp1 n
  WHERE e.empno = r.mgr and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 10:
## - recursive with RECURSIVE Query: Join Order tests 
##                         disemp >< emp1 >< pump  
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, emp1 n, rw r
  WHERE e.mgr = n.empno and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
===========================================================
|ID|OPERATOR                   |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |SORT                       |    |1001    |361         |
|1 |└─SUBPLAN SCAN             |rw  |1001    |55          |
|2 |  └─RECURSIVE UNION ALL    |    |1001    |52          |
|3 |    ├─HASH JOIN            |    |79      |16          |
|4 |    │ ├─HASH JOIN          |    |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN  |e   |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN  |n1  |17      |3           |
|7 |    │ └─TABLE FULL SCAN    |n2  |17      |3           |
|8 |    └─HASH JOIN            |    |922     |34          |
|9 |      │ MATERIAL           |    |22      |10          |
|10|      └─│ HASH JOIN        |    |22      |8           |
|11|        │ ├─TABLE FULL SCAN|e   |5       |3           |
|12|        │ └─TABLE FULL SCAN|n   |17      |3           |
|13|        TABLE FULL SCAN    |r   |199     |1           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
  9 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
 10 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n.empno, DECIMAL(-1, -1))]), other_conds(nil)
 11 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, emp1 n, rw r
  WHERE e.mgr = n.empno and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 11:
## - recursive with RECURSIVE Query: Join Order tests 
##                         emp1 >< disemp >< pump  
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
===========================================================
|ID|OPERATOR                   |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |SORT                       |    |1001    |364         |
|1 |└─SUBPLAN SCAN             |rw  |1001    |57          |
|2 |  └─RECURSIVE UNION ALL    |    |1001    |55          |
|3 |    ├─HASH JOIN            |    |79      |16          |
|4 |    │ ├─HASH JOIN          |    |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN  |e   |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN  |n1  |17      |3           |
|7 |    │ └─TABLE FULL SCAN    |n2  |17      |3           |
|8 |    └─HASH JOIN            |    |922     |37          |
|9 |      │ MATERIAL           |    |22      |13          |
|10|      └─│ HASH JOIN        |    |22      |11          |
|11|        │ ├─TABLE FULL SCAN|n   |17      |3           |
|12|        │ └─TABLE FULL SCAN|e   |5       |3           |
|13|        TABLE FULL SCAN    |r   |199     |1           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
  9 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
 10 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
      equal_conds([cast(n.empno, DECIMAL(-1, -1)) = e.MGR]), other_conds(nil)
 11 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 12 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 13 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 12:
## - recursive with RECURSIVE Query: Join Order tests 
##                         pump >< disemp
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |433     |117         |
|1 |└─RECURSIVE UNION ALL|    |433     |116         |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |432     |112         |
|4 |    ├─TABLE FULL SCAN|r   |199     |1           |
|5 |    └─TABLE FULL SCAN|e   |14      |3           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
  5 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| JONES  |  7566 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| SCOTT  |  7788 | 7566 |
| FORD   |  7902 | 7566 |
| ALLEN  |  7499 | 7698 |
| WARD   |  7521 | 7698 |
| MARTIN |  7654 | 7698 |
| TURNER |  7844 | 7698 |
| JAMES  |  7900 | 7698 |
| MILLER |  7934 | 7782 |
| ADAMS  |  7876 | 7788 |
| SMITH  |  7369 | 7902 |
+--------+-------+------+

## =======================================================================
## Test Case 13:
## - recursive with RECURSIVE Query: Join Order tests 
##                         disemp >< pump
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM  disemp e, rw r
    WHERE e.mgr = r.empno
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |433     |30          |
|1 |└─RECURSIVE UNION ALL|    |433     |29          |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |432     |26          |
|4 |    ├─TABLE FULL SCAN|e   |14      |3           |
|5 |    └─TABLE FULL SCAN|r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([e.MGR = r.empno]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM  disemp e, rw r
    WHERE e.mgr = r.empno
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 14:
## - recursive with RECURSIVE Query: Join Order tests 
##                         emp1 >< pump >< disemp
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, rw r, disemp e
  WHERE n.empno = e.mgr and r.mgr = e.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
===================================================================
|ID|OPERATOR                           |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |SORT                               |    |1001    |1885        |
|1 |└─SUBPLAN SCAN                     |rw  |1001    |1578        |
|2 |  └─RECURSIVE UNION ALL            |    |1001    |1576        |
|3 |    ├─HASH JOIN                    |    |79      |16          |
|4 |    │ ├─HASH JOIN                  |    |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN          |e   |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN          |n1  |17      |3           |
|7 |    │ └─TABLE FULL SCAN            |n2  |17      |3           |
|8 |    └─HASH JOIN                    |    |922     |1558        |
|9 |      ├─NESTED-LOOP JOIN CARTESIAN |    |3383    |92          |
|10|      │ ├─TABLE FULL SCAN          |r   |199     |1           |
|11|      │ └─MATERIAL                 |    |17      |5           |
|12|      │   └─TABLE FULL SCAN        |n   |17      |3           |
|13|      └─TABLE FULL SCAN            |e   |5       |3           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([cast(n.empno, DECIMAL(-1, -1)) = e.MGR], [r.mgr = e.EMPno]), other_conds(nil)
  9 - output([r.empno], [r.mgr], [r.iters], [r.sal], [n.empno]), filter(nil), rowset=256
      conds(nil), nl_params_(nil), use_batch=false
 10 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 11 - output([n.empno]), filter(nil), rowset=256
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, rw r, disemp e
  WHERE n.empno = e.mgr and r.mgr = e.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 15:
## - recursive with RECURSIVE Query: Join Order tests 
##                         pump >< emp1 >< disemp
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, emp1 n, disemp e
  WHERE r.mgr = e.empno and n.empno = e.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
===================================================================
|ID|OPERATOR                           |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |SORT                               |    |1001    |1885        |
|1 |└─SUBPLAN SCAN                     |rw  |1001    |1578        |
|2 |  └─RECURSIVE UNION ALL            |    |1001    |1576        |
|3 |    ├─HASH JOIN                    |    |79      |16          |
|4 |    │ ├─HASH JOIN                  |    |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN          |e   |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN          |n1  |17      |3           |
|7 |    │ └─TABLE FULL SCAN            |n2  |17      |3           |
|8 |    └─HASH JOIN                    |    |922     |1558        |
|9 |      ├─NESTED-LOOP JOIN CARTESIAN |    |3383    |92          |
|10|      │ ├─TABLE FULL SCAN          |r   |199     |1           |
|11|      │ └─MATERIAL                 |    |17      |5           |
|12|      │   └─TABLE FULL SCAN        |n   |17      |3           |
|13|      └─TABLE FULL SCAN            |e   |5       |3           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([r.mgr = e.EMPno], [cast(n.empno, DECIMAL(-1, -1)) = e.MGR]), other_conds(nil)
  9 - output([r.empno], [r.mgr], [r.iters], [r.sal], [n.empno]), filter(nil), rowset=256
      conds(nil), nl_params_(nil), use_batch=false
 10 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 11 - output([n.empno]), filter(nil), rowset=256
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, emp1 n, disemp e
  WHERE r.mgr = e.empno and n.empno = e.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 16:
## - recursive with RECURSIVE Query: Join Skew handling. No local filter
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |433     |30          |
|1 |└─RECURSIVE UNION ALL|    |433     |29          |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |432     |26          |
|4 |    ├─TABLE FULL SCAN|e   |14      |3           |
|5 |    └─TABLE FULL SCAN|r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 17:
## - recursive with RECURSIVE Query: Join Skew handling with RECURSIVE an additional local filter
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr and e.empno < e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |255     |27          |
|1 |└─RECURSIVE UNION ALL|    |255     |27          |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |254     |24          |
|4 |    ├─TABLE FULL SCAN|e   |5       |3           |
|5 |    └─TABLE FULL SCAN|r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.EMPno], [e.ENAME]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.ENAME]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr and e.empno < e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
+--------+-------+------+

##############################
##   section 2  聚合的两表是分布式表（disemp，emp1）
##############################
##  
##  emp1 也进行分布式化
drop table emp1;
CREATE TABLE emp1 (
   empno    VARCHAR(4000) NOT NULL,
   ename    VARCHAR(14),
   job      VARCHAR(9),
   mgr      VARCHAR(4000),
   hiredate DATE,
   sal      NUMBER(7,2),
   comm     NUMBER(7,2),
   deptno   NUMBER(2)
);

INSERT INTO emp1 values (7369, 'SMITH', 'CLERK', 7902, str_to_date('1980-12-17', '%Y-%m-%d'), 800, null, 20);
INSERT INTO emp1 values (7499, 'ALLEN', 'SALESMAN', 7698, str_to_date('1981-02-20', '%Y-%m-%d'), 1600, 300, 30);
INSERT INTO emp1 values (7521, 'WARD', 'SALESMAN', 7698, str_to_date('1981-02-22', '%Y-%m-%d'), 1250, 500, 30);
INSERT INTO emp1 values (7566, 'JONES', 'MANAGER', 7839, str_to_date('1981-08-02', '%Y-%m-%d'), 2975, null, 20);
INSERT INTO emp1 values (7654, 'MARTIN', 'SALESMAN', 7698, str_to_date('1981-09-28', '%Y-%m-%d'), 1250, 1400, 30);
INSERT INTO emp1 values (7698, 'BLAKE', 'MANAGER', 7839, str_to_date('1981-05-01', '%Y-%m-%d'), 2850, null, 30);
INSERT INTO emp1 values (7782, 'CLARK', 'MANAGER', 7839, str_to_date('1981-06-09' , '%Y-%m-%d'), 2450, null, 10);
INSERT INTO emp1 values (7788, 'SCOTT', 'ANALYST', 7566, str_to_date('1987-08-19', '%Y-%m-%d'), 3000, null, 20);
INSERT INTO emp1 values (7839, 'KING', 'PRESIDENT', null, str_to_date('1981-11-17', '%Y-%m-%d'), 5000, null, 10);
INSERT INTO emp1 values (7844, 'TURNER', 'SALESMAN', 7698, str_to_date('1981-09-08', '%Y-%m-%d'), 1500, 0, 30);
INSERT INTO emp1 values (7876, 'ADAMS', 'CLERK', 7788, str_to_date('1987-05-23', '%Y-%m-%d'), 1100, null, 20);
INSERT INTO emp1 values (7900, 'JAMES', 'CLERK', 7698, str_to_date('1981-12-03', '%Y-%m-%d'), 950, null, 30);
INSERT INTO emp1 values (7902, 'FORD', 'ANALYST', 7566, str_to_date('1981-12-03', '%Y-%m-%d'), 3000, null, 20);
INSERT INTO emp1 values (7934, 'MILLER', 'CLERK', 7782, str_to_date('1982-01-23', '%Y-%m-%d'), 1300, null, 10);
INSERT INTO emp1 values (8100, 'Eve', 'MANAGER', 7839, str_to_date('1984-05-01', '%Y-%m-%d'), 2850, null, 30);
INSERT INTO emp1 values (8101, 'Eve1', 'MANAGER', 8100, str_to_date('1984-05-01','%Y-%m-%d'), 2850, null, 30);
INSERT INTO emp1 values (8108, 'Eve8', 'CLERK', 8101, str_to_date('1984-05-01', '%Y-%m-%d'), 2850, null, 30);

## =======================================================================
## Test Case 1:
## - recursive with RECURSIVE Query: Nested Loop Join
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_NL(r e) */  e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=======================================================
|ID|OPERATOR               |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------------
|0 |SUBPLAN SCAN           |rw  |433     |68          |
|1 |└─RECURSIVE UNION ALL  |    |433     |67          |
|2 |  ├─TABLE FULL SCAN    |e   |1       |3           |
|3 |  └─NESTED-LOOP JOIN   |    |432     |64          |
|4 |    ├─TABLE FULL SCAN  |r   |199     |1           |
|5 |    └─MATERIAL         |    |14      |5           |
|6 |      └─TABLE FULL SCAN|e   |14      |3           |
=======================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      conds([r.empno = e.MGR]), nl_params_(nil), use_batch=false
  4 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
  5 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
  6 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_NL(r e) */  e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| JONES  |  7566 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| SCOTT  |  7788 | 7566 |
| FORD   |  7902 | 7566 |
| ALLEN  |  7499 | 7698 |
| WARD   |  7521 | 7698 |
| MARTIN |  7654 | 7698 |
| TURNER |  7844 | 7698 |
| JAMES  |  7900 | 7698 |
| MILLER |  7934 | 7782 |
| ADAMS  |  7876 | 7788 |
| SMITH  |  7369 | 7902 |
+--------+-------+------+

## =======================================================================
## Test Case 2:
## - recursive with RECURSIVE Query: SORT MERGE Join
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_MERGE(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=========================================================
|ID|OPERATOR                 |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |SUBPLAN SCAN             |rw  |433     |137         |
|1 |└─RECURSIVE UNION ALL    |    |433     |135         |
|2 |  ├─TABLE FULL SCAN      |e   |1       |3           |
|3 |  └─MERGE JOIN           |    |432     |132         |
|4 |    │ MATERIAL           |    |14      |7           |
|5 |    └─│ SORT             |    |14      |5           |
|6 |      │ └─TABLE FULL SCAN|e   |14      |3           |
|7 |      SORT               |    |199     |107         |
|8 |      └─TABLE FULL SCAN  |r   |199     |1           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
      merge_directions([ASC])
  4 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
<<<<<<< HEAD
  5 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256, sort_keys([e.MGR, ASC])
  6 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256,
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
  7 - output([r.empno]), filter(nil), rowset=256, sort_keys([r.empno, ASC])
  8 - output([r.empno]), filter(nil), rowset=256,
      access([r.empno]), partitions is NULL,

=======
  5 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      sort_keys([e.MGR, ASC])
  6 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  7 - output([r.empno]), filter(nil), rowset=256
      sort_keys([r.empno, ASC])
  8 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
>>>>>>> 529367cd9b5b9b1ee0672ddeef2a9930fe7b95fe

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_MERGE(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| JONES  |  7566 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| SCOTT  |  7788 | 7566 |
| FORD   |  7902 | 7566 |
| ALLEN  |  7499 | 7698 |
| WARD   |  7521 | 7698 |
| MARTIN |  7654 | 7698 |
| TURNER |  7844 | 7698 |
| JAMES  |  7900 | 7698 |
| MILLER |  7934 | 7782 |
| ADAMS  |  7876 | 7788 |
| SMITH  |  7369 | 7902 |
+--------+-------+------+

## =======================================================================
## Test Case 3:
## - recursive with RECURSIVE Query: Hash Join
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |433     |30          |
|1 |└─RECURSIVE UNION ALL|    |433     |29          |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |432     |26          |
|4 |    ├─TABLE FULL SCAN|e   |14      |3           |
|5 |    └─TABLE FULL SCAN|r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 4:
## - recursive with RECURSIVE Query: Join in Initialisation Branch
## 与oracle的结果顺序不一样
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT /*+ USE_NL(e d) */ e.ename, e.mgr, e.empno
    FROM disemp e, disemp d 
    WHERE e.sal = d. sal
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e, disemp d
    WHERE r.empno = e.mgr and e.sal = d.sal
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=========================================================
|ID|OPERATOR                 |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |SUBPLAN SCAN             |rw  |520     |46          |
|1 |└─RECURSIVE UNION ALL    |    |520     |44          |
|2 |  ├─NESTED-LOOP JOIN     |    |17      |9           |
|3 |  │ ├─TABLE FULL SCAN    |e   |14      |3           |
|4 |  │ └─MATERIAL           |    |14      |3           |
|5 |  │   └─TABLE FULL SCAN  |d   |14      |3           |
|6 |  └─HASH JOIN            |    |504     |34          |
|7 |    │ MATERIAL           |    |17      |11          |
|8 |    └─│ HASH JOIN        |    |17      |9           |
|9 |      │ ├─TABLE FULL SCAN|d   |14      |3           |
|10|      │ └─TABLE FULL SCAN|e   |14      |3           |
|11|      TABLE FULL SCAN    |r   |199     |1           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      conds([e.SAL = d.SAL]), nl_params_(nil), use_batch=false
  3 - output([e.SAL], [e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      access([e.SAL], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  4 - output([d.SAL]), filter(nil), rowset=256
  5 - output([d.SAL]), filter(nil), rowset=256
      access([d.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([d.__pk_increment]), range(MIN ; MAX)always true
  6 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  7 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
  8 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([e.SAL = d.SAL]), other_conds(nil)
  9 - output([d.SAL]), filter(nil), rowset=256
      access([d.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([d.__pk_increment]), range(MIN ; MAX)always true
 10 - output([e.MGR], [e.SAL], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.SAL], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 11 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT /*+ USE_NL(e d) */ e.ename, e.mgr, e.empno
    FROM disemp e, disemp d 
    WHERE e.sal = d. sal
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e, disemp d
    WHERE r.empno = e.mgr and e.sal = d.sal
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ALLEN  |  7499 | 7698 |
| ALLEN  |  7499 | 7698 |
| ALLEN  |  7499 | 7698 |
| BLAKE  |  7698 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| CLARK  |  7782 | 7839 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| JAMES  |  7900 | 7698 |
| JAMES  |  7900 | 7698 |
| JAMES  |  7900 | 7698 |
| JONES  |  7566 | 7839 |
| JONES  |  7566 | 7839 |
| KING   |  7839 | NULL |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MILLER |  7934 | 7782 |
| MILLER |  7934 | 7782 |
| MILLER |  7934 | 7782 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| TURNER |  7844 | 7698 |
| TURNER |  7844 | 7698 |
| TURNER |  7844 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
+--------+-------+------+

## =======================================================================
## Test Case 6:
## - recursive with RECURSIVE Query: Hash Join without using hints
##                         Static input on build side and fits in memory
## 与oracle顺序不一致
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM disemp e, rw r
    WHERE e.mgr = r.empno 
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |433     |30          |
|1 |└─RECURSIVE UNION ALL|    |433     |29          |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |432     |26          |
|4 |    ├─TABLE FULL SCAN|e   |14      |3           |
|5 |    └─TABLE FULL SCAN|r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([e.MGR = r.empno]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM disemp e, rw r
    WHERE e.mgr = r.empno 
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 7:
## - recursive with RECURSIVE Query: Hash Join without using hints
##                         Static input on probe side and fits in memory
## =======================================================================
explain  
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |433     |30          |
|1 |└─RECURSIVE UNION ALL|    |433     |29          |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |432     |26          |
|4 |    ├─TABLE FULL SCAN|e   |14      |3           |
|5 |    └─TABLE FULL SCAN|r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## 测试8-15都是在测试join的顺序或者hint的顺序
## Test Case 8:
## - recursive with RECURSIVE Query: Join Order tests 
##                         pump >< disemp >< emp1 
## =======================================================================
explain  
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, disemp e, emp1 n
  WHERE r.mgr = e.empno and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
=========================================================
|ID|OPERATOR                 |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |SORT                     |    |1001    |501         |
|1 |└─SUBPLAN SCAN           |rw  |1001    |195         |
|2 |  └─RECURSIVE UNION ALL  |    |1001    |192         |
|3 |    ├─HASH JOIN          |    |79      |16          |
|4 |    │ ├─HASH JOIN        |    |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN|e   |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN|n1  |17      |3           |
|7 |    │ └─TABLE FULL SCAN  |n2  |17      |3           |
|8 |    └─HASH JOIN          |    |922     |175         |
|9 |      ├─HASH JOIN        |    |199     |112         |
|10|      │ ├─TABLE FULL SCAN|r   |199     |1           |
|11|      │ └─TABLE FULL SCAN|e   |5       |3           |
|12|      └─TABLE FULL SCAN  |n   |17      |3           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n.empno, DECIMAL(-1, -1))]), other_conds(nil)
  9 - output([r.empno], [e.MGR], [r.iters], [r.sal], [e.SAL]), filter(nil), rowset=256
      equal_conds([r.mgr = e.EMPno]), other_conds(nil)
 10 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 11 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, disemp e, emp1 n
  WHERE r.mgr = e.empno and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 9:
## - recursive with RECURSIVE Query: Join Order tests 
##                         disemp >< pump >< emp1 
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, rw r, emp1 n
  WHERE e.empno = r.mgr and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
=========================================================
|ID|OPERATOR                 |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |SORT                     |    |1001    |413         |
|1 |└─SUBPLAN SCAN           |rw  |1001    |107         |
|2 |  └─RECURSIVE UNION ALL  |    |1001    |104         |
|3 |    ├─HASH JOIN          |    |79      |16          |
|4 |    │ ├─HASH JOIN        |    |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN|e   |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN|n1  |17      |3           |
|7 |    │ └─TABLE FULL SCAN  |n2  |17      |3           |
|8 |    └─HASH JOIN          |    |922     |86          |
|9 |      ├─HASH JOIN        |    |199     |23          |
|10|      │ ├─TABLE FULL SCAN|e   |5       |3           |
|11|      │ └─TABLE FULL SCAN|r   |199     |1           |
|12|      └─TABLE FULL SCAN  |n   |17      |3           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n.empno, DECIMAL(-1, -1))]), other_conds(nil)
  9 - output([r.empno], [e.MGR], [e.SAL], [r.iters], [r.sal]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
 10 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 11 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, rw r, emp1 n
  WHERE e.empno = r.mgr and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 10:
## - recursive with RECURSIVE Query: Join Order tests 
##                         disemp >< emp1 >< pump  
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, emp1 n, rw r
  WHERE e.mgr = n.empno and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
===========================================================
|ID|OPERATOR                   |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |SORT                       |    |1001    |361         |
|1 |└─SUBPLAN SCAN             |rw  |1001    |55          |
|2 |  └─RECURSIVE UNION ALL    |    |1001    |52          |
|3 |    ├─HASH JOIN            |    |79      |16          |
|4 |    │ ├─HASH JOIN          |    |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN  |e   |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN  |n1  |17      |3           |
|7 |    │ └─TABLE FULL SCAN    |n2  |17      |3           |
|8 |    └─HASH JOIN            |    |922     |34          |
|9 |      │ MATERIAL           |    |22      |10          |
|10|      └─│ HASH JOIN        |    |22      |8           |
|11|        │ ├─TABLE FULL SCAN|e   |5       |3           |
|12|        │ └─TABLE FULL SCAN|n   |17      |3           |
|13|        TABLE FULL SCAN    |r   |199     |1           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
  9 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
 10 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n.empno, DECIMAL(-1, -1))]), other_conds(nil)
 11 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, emp1 n, rw r
  WHERE e.mgr = n.empno and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 11:
## - recursive with RECURSIVE Query: Join Order tests 
##                         emp1 >< disemp >< pump  
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
===========================================================
|ID|OPERATOR                   |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |SORT                       |    |1001    |364         |
|1 |└─SUBPLAN SCAN             |rw  |1001    |57          |
|2 |  └─RECURSIVE UNION ALL    |    |1001    |55          |
|3 |    ├─HASH JOIN            |    |79      |16          |
|4 |    │ ├─HASH JOIN          |    |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN  |e   |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN  |n1  |17      |3           |
|7 |    │ └─TABLE FULL SCAN    |n2  |17      |3           |
|8 |    └─HASH JOIN            |    |922     |37          |
|9 |      │ MATERIAL           |    |22      |13          |
|10|      └─│ HASH JOIN        |    |22      |11          |
|11|        │ ├─TABLE FULL SCAN|n   |17      |3           |
|12|        │ └─TABLE FULL SCAN|e   |5       |3           |
|13|        TABLE FULL SCAN    |r   |199     |1           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
  9 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
 10 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
      equal_conds([cast(n.empno, DECIMAL(-1, -1)) = e.MGR]), other_conds(nil)
 11 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 12 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 13 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

##oracle ok
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 12:
## - recursive with RECURSIVE Query: Join Order tests 
##                         pump >< disemp
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |433     |117         |
|1 |└─RECURSIVE UNION ALL|    |433     |116         |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |432     |112         |
|4 |    ├─TABLE FULL SCAN|r   |199     |1           |
|5 |    └─TABLE FULL SCAN|e   |14      |3           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
  5 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| JONES  |  7566 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| SCOTT  |  7788 | 7566 |
| FORD   |  7902 | 7566 |
| ALLEN  |  7499 | 7698 |
| WARD   |  7521 | 7698 |
| MARTIN |  7654 | 7698 |
| TURNER |  7844 | 7698 |
| JAMES  |  7900 | 7698 |
| MILLER |  7934 | 7782 |
| ADAMS  |  7876 | 7788 |
| SMITH  |  7369 | 7902 |
+--------+-------+------+

## =======================================================================
## Test Case 13:
## - recursive with RECURSIVE Query: Join Order tests 
##                         disemp >< pump
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM  disemp e, rw r
    WHERE e.mgr = r.empno
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |433     |30          |
|1 |└─RECURSIVE UNION ALL|    |433     |29          |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |432     |26          |
|4 |    ├─TABLE FULL SCAN|e   |14      |3           |
|5 |    └─TABLE FULL SCAN|r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([e.MGR = r.empno]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM  disemp e, rw r
    WHERE e.mgr = r.empno
)
SELECT /*+log_level(DEBUG)*/ ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 14:
## - recursive with RECURSIVE Query: Join Order tests 
##                         emp1 >< pump >< disemp
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, rw r, disemp e
  WHERE n.empno = e.mgr and r.mgr = e.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
===================================================================
|ID|OPERATOR                           |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |SORT                               |    |1001    |1885        |
|1 |└─SUBPLAN SCAN                     |rw  |1001    |1578        |
|2 |  └─RECURSIVE UNION ALL            |    |1001    |1576        |
|3 |    ├─HASH JOIN                    |    |79      |16          |
|4 |    │ ├─HASH JOIN                  |    |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN          |e   |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN          |n1  |17      |3           |
|7 |    │ └─TABLE FULL SCAN            |n2  |17      |3           |
|8 |    └─HASH JOIN                    |    |922     |1558        |
|9 |      ├─NESTED-LOOP JOIN CARTESIAN |    |3383    |92          |
|10|      │ ├─TABLE FULL SCAN          |r   |199     |1           |
|11|      │ └─MATERIAL                 |    |17      |5           |
|12|      │   └─TABLE FULL SCAN        |n   |17      |3           |
|13|      └─TABLE FULL SCAN            |e   |5       |3           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([cast(n.empno, DECIMAL(-1, -1)) = e.MGR], [r.mgr = e.EMPno]), other_conds(nil)
  9 - output([r.empno], [r.mgr], [r.iters], [r.sal], [n.empno]), filter(nil), rowset=256
      conds(nil), nl_params_(nil), use_batch=false
 10 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 11 - output([n.empno]), filter(nil), rowset=256
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, rw r, disemp e
  WHERE n.empno = e.mgr and r.mgr = e.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 15:
## - recursive with RECURSIVE Query: Join Order tests 
##                         pump >< emp1 >< disemp
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, emp1 n, disemp e
  WHERE r.mgr = e.empno and n.empno = e.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
===================================================================
|ID|OPERATOR                           |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |SORT                               |    |1001    |1885        |
|1 |└─SUBPLAN SCAN                     |rw  |1001    |1578        |
|2 |  └─RECURSIVE UNION ALL            |    |1001    |1576        |
|3 |    ├─HASH JOIN                    |    |79      |16          |
|4 |    │ ├─HASH JOIN                  |    |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN          |e   |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN          |n1  |17      |3           |
|7 |    │ └─TABLE FULL SCAN            |n2  |17      |3           |
|8 |    └─HASH JOIN                    |    |922     |1558        |
|9 |      ├─NESTED-LOOP JOIN CARTESIAN |    |3383    |92          |
|10|      │ ├─TABLE FULL SCAN          |r   |199     |1           |
|11|      │ └─MATERIAL                 |    |17      |5           |
|12|      │   └─TABLE FULL SCAN        |n   |17      |3           |
|13|      └─TABLE FULL SCAN            |e   |5       |3           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([r.mgr = e.EMPno], [cast(n.empno, DECIMAL(-1, -1)) = e.MGR]), other_conds(nil)
  9 - output([r.empno], [r.mgr], [r.iters], [r.sal], [n.empno]), filter(nil), rowset=256
      conds(nil), nl_params_(nil), use_batch=false
 10 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 11 - output([n.empno]), filter(nil), rowset=256
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, emp1 n, disemp e
  WHERE r.mgr = e.empno and n.empno = e.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 16:
## - recursive with RECURSIVE Query: Join Skew handling. No local filter
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |433     |30          |
|1 |└─RECURSIVE UNION ALL|    |433     |29          |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |432     |26          |
|4 |    ├─TABLE FULL SCAN|e   |14      |3           |
|5 |    └─TABLE FULL SCAN|r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 17:
## - recursive with RECURSIVE Query: Join Skew handling with RECURSIVE an additional local filter
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr and e.empno < e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |255     |27          |
|1 |└─RECURSIVE UNION ALL|    |255     |27          |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |254     |24          |
|4 |    ├─TABLE FULL SCAN|e   |5       |3           |
|5 |    └─TABLE FULL SCAN|r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.EMPno], [e.ENAME]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.ENAME]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr and e.empno < e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
+--------+-------+------+

##############################
##   section 3  聚合的两表在join条件上可能形成wise join（disemp，emp1）
##############################
##
##  emp1 也进行分布式化
drop table emp1;
CREATE TABLE emp1 (
   empno    VARCHAR(4000) NOT NULL,
   ename    VARCHAR(14),
   job      VARCHAR(9),
   mgr      VARCHAR(4000),
   hiredate DATE,
   sal      NUMBER(7,2),
   comm     NUMBER(7,2),
   deptno   NUMBER(2)
);

INSERT INTO emp1 values (7369, 'SMITH', 'CLERK', 7902, str_to_date('1980-12-17', '%Y-%m-%d'), 800, null, 20);
INSERT INTO emp1 values (7499, 'ALLEN', 'SALESMAN', 7698, str_to_date('1981-02-20', '%Y-%m-%d'), 1600, 300, 30);
INSERT INTO emp1 values (7521, 'WARD', 'SALESMAN', 7698, str_to_date('1981-02-22', '%Y-%m-%d'), 1250, 500, 30);
INSERT INTO emp1 values (7566, 'JONES', 'MANAGER', 7839, str_to_date('1981-08-02', '%Y-%m-%d'), 2975, null, 20);
INSERT INTO emp1 values (7654, 'MARTIN', 'SALESMAN', 7698, str_to_date('1981-09-28', '%Y-%m-%d'), 1250, 1400, 30);
INSERT INTO emp1 values (7698, 'BLAKE', 'MANAGER', 7839, str_to_date('1981-05-01', '%Y-%m-%d'), 2850, null, 30);
INSERT INTO emp1 values (7782, 'CLARK', 'MANAGER', 7839, str_to_date('1981-06-09' , '%Y-%m-%d'), 2450, null, 10);
INSERT INTO emp1 values (7788, 'SCOTT', 'ANALYST', 7566, str_to_date('1987-08-19', '%Y-%m-%d'), 3000, null, 20);
INSERT INTO emp1 values (7839, 'KING', 'PRESIDENT', null, str_to_date('1981-11-17', '%Y-%m-%d'), 5000, null, 10);
INSERT INTO emp1 values (7844, 'TURNER', 'SALESMAN', 7698, str_to_date('1981-09-08', '%Y-%m-%d'), 1500, 0, 30);
INSERT INTO emp1 values (7876, 'ADAMS', 'CLERK', 7788, str_to_date('1987-05-23', '%Y-%m-%d'), 1100, null, 20);
INSERT INTO emp1 values (7900, 'JAMES', 'CLERK', 7698, str_to_date('1981-12-03', '%Y-%m-%d'), 950, null, 30);
INSERT INTO emp1 values (7902, 'FORD', 'ANALYST', 7566, str_to_date('1981-12-03', '%Y-%m-%d'), 3000, null, 20);
INSERT INTO emp1 values (7934, 'MILLER', 'CLERK', 7782, str_to_date('1982-01-23', '%Y-%m-%d'), 1300, null, 10);
INSERT INTO emp1 values (8100, 'Eve', 'MANAGER', 7839, str_to_date('1984-05-01', '%Y-%m-%d'), 2850, null, 30);
INSERT INTO emp1 values (8101, 'Eve1', 'MANAGER', 8100, str_to_date('1984-05-01','%Y-%m-%d'), 2850, null, 30);
INSERT INTO emp1 values (8108, 'Eve8', 'CLERK', 8101, str_to_date('1984-05-01', '%Y-%m-%d'), 2850, null, 30);

## =======================================================================
## Test Case 1:
## - recursive with RECURSIVE Query: Nested Loop Join
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_NL(r e) */  e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=======================================================
|ID|OPERATOR               |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------------
|0 |SUBPLAN SCAN           |rw  |433     |68          |
|1 |└─RECURSIVE UNION ALL  |    |433     |67          |
|2 |  ├─TABLE FULL SCAN    |e   |1       |3           |
|3 |  └─NESTED-LOOP JOIN   |    |432     |64          |
|4 |    ├─TABLE FULL SCAN  |r   |199     |1           |
|5 |    └─MATERIAL         |    |14      |5           |
|6 |      └─TABLE FULL SCAN|e   |14      |3           |
=======================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      conds([r.empno = e.MGR]), nl_params_(nil), use_batch=false
  4 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
  5 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
  6 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_NL(r e) */  e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| JONES  |  7566 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| SCOTT  |  7788 | 7566 |
| FORD   |  7902 | 7566 |
| ALLEN  |  7499 | 7698 |
| WARD   |  7521 | 7698 |
| MARTIN |  7654 | 7698 |
| TURNER |  7844 | 7698 |
| JAMES  |  7900 | 7698 |
| MILLER |  7934 | 7782 |
| ADAMS  |  7876 | 7788 |
| SMITH  |  7369 | 7902 |
+--------+-------+------+

## =======================================================================
## Test Case 2:
## - recursive with RECURSIVE Query: SORT MERGE Join
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_MERGE(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=========================================================
|ID|OPERATOR                 |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |SUBPLAN SCAN             |rw  |433     |137         |
|1 |└─RECURSIVE UNION ALL    |    |433     |135         |
|2 |  ├─TABLE FULL SCAN      |e   |1       |3           |
|3 |  └─MERGE JOIN           |    |432     |132         |
|4 |    │ MATERIAL           |    |14      |7           |
|5 |    └─│ SORT             |    |14      |5           |
|6 |      │ └─TABLE FULL SCAN|e   |14      |3           |
|7 |      SORT               |    |199     |107         |
|8 |      └─TABLE FULL SCAN  |r   |199     |1           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
      merge_directions([ASC])
  4 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
<<<<<<< HEAD
  5 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256, sort_keys([e.MGR, ASC])
  6 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256,
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
  7 - output([r.empno]), filter(nil), rowset=256, sort_keys([r.empno, ASC])
  8 - output([r.empno]), filter(nil), rowset=256,
      access([r.empno]), partitions is NULL,

=======
  5 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      sort_keys([e.MGR, ASC])
  6 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  7 - output([r.empno]), filter(nil), rowset=256
      sort_keys([r.empno, ASC])
  8 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
>>>>>>> 529367cd9b5b9b1ee0672ddeef2a9930fe7b95fe

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_MERGE(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| JONES  |  7566 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| SCOTT  |  7788 | 7566 |
| FORD   |  7902 | 7566 |
| ALLEN  |  7499 | 7698 |
| WARD   |  7521 | 7698 |
| MARTIN |  7654 | 7698 |
| TURNER |  7844 | 7698 |
| JAMES  |  7900 | 7698 |
| MILLER |  7934 | 7782 |
| ADAMS  |  7876 | 7788 |
| SMITH  |  7369 | 7902 |
+--------+-------+------+

## =======================================================================
## Test Case 3:
## - recursive with RECURSIVE Query: Hash Join
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |433     |30          |
|1 |└─RECURSIVE UNION ALL|    |433     |29          |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |432     |26          |
|4 |    ├─TABLE FULL SCAN|e   |14      |3           |
|5 |    └─TABLE FULL SCAN|r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT /*+log_level(DEBUG)*/ ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 4:
## - recursive with RECURSIVE Query: Join in Initialisation Branch
## 与oracle的结果顺序不一样
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT /*+ USE_NL(e d) */ e.ename, e.mgr, e.empno
    FROM disemp e, disemp d 
    WHERE e.sal = d. sal
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e, disemp d
    WHERE r.empno = e.mgr and e.sal = d.sal
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=========================================================
|ID|OPERATOR                 |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |SUBPLAN SCAN             |rw  |520     |46          |
|1 |└─RECURSIVE UNION ALL    |    |520     |44          |
|2 |  ├─NESTED-LOOP JOIN     |    |17      |9           |
|3 |  │ ├─TABLE FULL SCAN    |e   |14      |3           |
|4 |  │ └─MATERIAL           |    |14      |3           |
|5 |  │   └─TABLE FULL SCAN  |d   |14      |3           |
|6 |  └─HASH JOIN            |    |504     |34          |
|7 |    │ MATERIAL           |    |17      |11          |
|8 |    └─│ HASH JOIN        |    |17      |9           |
|9 |      │ ├─TABLE FULL SCAN|d   |14      |3           |
|10|      │ └─TABLE FULL SCAN|e   |14      |3           |
|11|      TABLE FULL SCAN    |r   |199     |1           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      conds([e.SAL = d.SAL]), nl_params_(nil), use_batch=false
  3 - output([e.SAL], [e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      access([e.SAL], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  4 - output([d.SAL]), filter(nil), rowset=256
  5 - output([d.SAL]), filter(nil), rowset=256
      access([d.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([d.__pk_increment]), range(MIN ; MAX)always true
  6 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  7 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
  8 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([e.SAL = d.SAL]), other_conds(nil)
  9 - output([d.SAL]), filter(nil), rowset=256
      access([d.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([d.__pk_increment]), range(MIN ; MAX)always true
 10 - output([e.MGR], [e.SAL], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.SAL], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 11 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT /*+ USE_NL(e d) */ e.ename, e.mgr, e.empno
    FROM disemp e, disemp d 
    WHERE e.sal = d. sal
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e, disemp d
    WHERE r.empno = e.mgr and e.sal = d.sal
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ALLEN  |  7499 | 7698 |
| ALLEN  |  7499 | 7698 |
| ALLEN  |  7499 | 7698 |
| BLAKE  |  7698 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| CLARK  |  7782 | 7839 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| JAMES  |  7900 | 7698 |
| JAMES  |  7900 | 7698 |
| JAMES  |  7900 | 7698 |
| JONES  |  7566 | 7839 |
| JONES  |  7566 | 7839 |
| KING   |  7839 | NULL |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MILLER |  7934 | 7782 |
| MILLER |  7934 | 7782 |
| MILLER |  7934 | 7782 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| TURNER |  7844 | 7698 |
| TURNER |  7844 | 7698 |
| TURNER |  7844 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
+--------+-------+------+

## =======================================================================
## Test Case 6:
## - recursive with RECURSIVE Query: Hash Join without using hints
##                         Static input on build side and fits in memory
## 与oracle顺序不一致
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM disemp e, rw r
    WHERE e.mgr = r.empno 
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |433     |30          |
|1 |└─RECURSIVE UNION ALL|    |433     |29          |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |432     |26          |
|4 |    ├─TABLE FULL SCAN|e   |14      |3           |
|5 |    └─TABLE FULL SCAN|r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([e.MGR = r.empno]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM disemp e, rw r
    WHERE e.mgr = r.empno 
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 7:
## - recursive with RECURSIVE Query: Hash Join without using hints
##                         Static input on probe side and fits in memory
## =======================================================================
explain  
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |433     |30          |
|1 |└─RECURSIVE UNION ALL|    |433     |29          |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |432     |26          |
|4 |    ├─TABLE FULL SCAN|e   |14      |3           |
|5 |    └─TABLE FULL SCAN|r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## 测试8-15都是在测试join的顺序或者hint的顺序
## Test Case 8:
## - recursive with RECURSIVE Query: Join Order tests 
##                         pump >< disemp >< emp1 
## =======================================================================
explain  
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, disemp e, emp1 n
  WHERE r.mgr = e.empno and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
=========================================================
|ID|OPERATOR                 |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |SORT                     |    |1001    |501         |
|1 |└─SUBPLAN SCAN           |rw  |1001    |195         |
|2 |  └─RECURSIVE UNION ALL  |    |1001    |192         |
|3 |    ├─HASH JOIN          |    |79      |16          |
|4 |    │ ├─HASH JOIN        |    |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN|e   |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN|n1  |17      |3           |
|7 |    │ └─TABLE FULL SCAN  |n2  |17      |3           |
|8 |    └─HASH JOIN          |    |922     |175         |
|9 |      ├─HASH JOIN        |    |199     |112         |
|10|      │ ├─TABLE FULL SCAN|r   |199     |1           |
|11|      │ └─TABLE FULL SCAN|e   |5       |3           |
|12|      └─TABLE FULL SCAN  |n   |17      |3           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n.empno, DECIMAL(-1, -1))]), other_conds(nil)
  9 - output([r.empno], [e.MGR], [r.iters], [r.sal], [e.SAL]), filter(nil), rowset=256
      equal_conds([r.mgr = e.EMPno]), other_conds(nil)
 10 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 11 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, disemp e, emp1 n
  WHERE r.mgr = e.empno and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 9:
## - recursive with RECURSIVE Query: Join Order tests 
##                         disemp >< pump >< emp1 
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, rw r, emp1 n
  WHERE e.empno = r.mgr and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
=========================================================
|ID|OPERATOR                 |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |SORT                     |    |1001    |413         |
|1 |└─SUBPLAN SCAN           |rw  |1001    |107         |
|2 |  └─RECURSIVE UNION ALL  |    |1001    |104         |
|3 |    ├─HASH JOIN          |    |79      |16          |
|4 |    │ ├─HASH JOIN        |    |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN|e   |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN|n1  |17      |3           |
|7 |    │ └─TABLE FULL SCAN  |n2  |17      |3           |
|8 |    └─HASH JOIN          |    |922     |86          |
|9 |      ├─HASH JOIN        |    |199     |23          |
|10|      │ ├─TABLE FULL SCAN|e   |5       |3           |
|11|      │ └─TABLE FULL SCAN|r   |199     |1           |
|12|      └─TABLE FULL SCAN  |n   |17      |3           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n.empno, DECIMAL(-1, -1))]), other_conds(nil)
  9 - output([r.empno], [e.MGR], [e.SAL], [r.iters], [r.sal]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
 10 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 11 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, rw r, emp1 n
  WHERE e.empno = r.mgr and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 10:
## - recursive with RECURSIVE Query: Join Order tests 
##                         disemp >< emp1 >< pump  
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, emp1 n, rw r
  WHERE e.mgr = n.empno and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
===========================================================
|ID|OPERATOR                   |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |SORT                       |    |1001    |361         |
|1 |└─SUBPLAN SCAN             |rw  |1001    |55          |
|2 |  └─RECURSIVE UNION ALL    |    |1001    |52          |
|3 |    ├─HASH JOIN            |    |79      |16          |
|4 |    │ ├─HASH JOIN          |    |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN  |e   |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN  |n1  |17      |3           |
|7 |    │ └─TABLE FULL SCAN    |n2  |17      |3           |
|8 |    └─HASH JOIN            |    |922     |34          |
|9 |      │ MATERIAL           |    |22      |10          |
|10|      └─│ HASH JOIN        |    |22      |8           |
|11|        │ ├─TABLE FULL SCAN|e   |5       |3           |
|12|        │ └─TABLE FULL SCAN|n   |17      |3           |
|13|        TABLE FULL SCAN    |r   |199     |1           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
  9 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
 10 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n.empno, DECIMAL(-1, -1))]), other_conds(nil)
 11 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, emp1 n, rw r
  WHERE e.mgr = n.empno and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 11:
## - recursive with RECURSIVE Query: Join Order tests 
##                         emp1 >< disemp >< pump  
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
===========================================================
|ID|OPERATOR                   |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |SORT                       |    |1001    |364         |
|1 |└─SUBPLAN SCAN             |rw  |1001    |57          |
|2 |  └─RECURSIVE UNION ALL    |    |1001    |55          |
|3 |    ├─HASH JOIN            |    |79      |16          |
|4 |    │ ├─HASH JOIN          |    |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN  |e   |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN  |n1  |17      |3           |
|7 |    │ └─TABLE FULL SCAN    |n2  |17      |3           |
|8 |    └─HASH JOIN            |    |922     |37          |
|9 |      │ MATERIAL           |    |22      |13          |
|10|      └─│ HASH JOIN        |    |22      |11          |
|11|        │ ├─TABLE FULL SCAN|n   |17      |3           |
|12|        │ └─TABLE FULL SCAN|e   |5       |3           |
|13|        TABLE FULL SCAN    |r   |199     |1           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
  9 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
 10 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
      equal_conds([cast(n.empno, DECIMAL(-1, -1)) = e.MGR]), other_conds(nil)
 11 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 12 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 13 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 12:
## - recursive with RECURSIVE Query: Join Order tests 
##                         pump >< disemp
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |433     |117         |
|1 |└─RECURSIVE UNION ALL|    |433     |116         |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |432     |112         |
|4 |    ├─TABLE FULL SCAN|r   |199     |1           |
|5 |    └─TABLE FULL SCAN|e   |14      |3           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
  5 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| JONES  |  7566 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| SCOTT  |  7788 | 7566 |
| FORD   |  7902 | 7566 |
| ALLEN  |  7499 | 7698 |
| WARD   |  7521 | 7698 |
| MARTIN |  7654 | 7698 |
| TURNER |  7844 | 7698 |
| JAMES  |  7900 | 7698 |
| MILLER |  7934 | 7782 |
| ADAMS  |  7876 | 7788 |
| SMITH  |  7369 | 7902 |
+--------+-------+------+

## =======================================================================
## Test Case 13:
## - recursive with RECURSIVE Query: Join Order tests 
##                         disemp >< pump
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM  disemp e, rw r
    WHERE e.mgr = r.empno
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |433     |30          |
|1 |└─RECURSIVE UNION ALL|    |433     |29          |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |432     |26          |
|4 |    ├─TABLE FULL SCAN|e   |14      |3           |
|5 |    └─TABLE FULL SCAN|r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([e.MGR = r.empno]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM  disemp e, rw r
    WHERE e.mgr = r.empno
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 14:
## - recursive with RECURSIVE Query: Join Order tests 
##                         emp1 >< pump >< disemp
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, rw r, disemp e
  WHERE n.empno = e.mgr and r.mgr = e.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
===================================================================
|ID|OPERATOR                           |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |SORT                               |    |1001    |1885        |
|1 |└─SUBPLAN SCAN                     |rw  |1001    |1578        |
|2 |  └─RECURSIVE UNION ALL            |    |1001    |1576        |
|3 |    ├─HASH JOIN                    |    |79      |16          |
|4 |    │ ├─HASH JOIN                  |    |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN          |e   |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN          |n1  |17      |3           |
|7 |    │ └─TABLE FULL SCAN            |n2  |17      |3           |
|8 |    └─HASH JOIN                    |    |922     |1558        |
|9 |      ├─NESTED-LOOP JOIN CARTESIAN |    |3383    |92          |
|10|      │ ├─TABLE FULL SCAN          |r   |199     |1           |
|11|      │ └─MATERIAL                 |    |17      |5           |
|12|      │   └─TABLE FULL SCAN        |n   |17      |3           |
|13|      └─TABLE FULL SCAN            |e   |5       |3           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([cast(n.empno, DECIMAL(-1, -1)) = e.MGR], [r.mgr = e.EMPno]), other_conds(nil)
  9 - output([r.empno], [r.mgr], [r.iters], [r.sal], [n.empno]), filter(nil), rowset=256
      conds(nil), nl_params_(nil), use_batch=false
 10 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 11 - output([n.empno]), filter(nil), rowset=256
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, rw r, disemp e
  WHERE n.empno = e.mgr and r.mgr = e.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 15:
## - recursive with RECURSIVE Query: Join Order tests 
##                         pump >< emp1 >< disemp
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, emp1 n, disemp e
  WHERE r.mgr = e.empno and n.empno = e.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
===================================================================
|ID|OPERATOR                           |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |SORT                               |    |1001    |1885        |
|1 |└─SUBPLAN SCAN                     |rw  |1001    |1578        |
|2 |  └─RECURSIVE UNION ALL            |    |1001    |1576        |
|3 |    ├─HASH JOIN                    |    |79      |16          |
|4 |    │ ├─HASH JOIN                  |    |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN          |e   |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN          |n1  |17      |3           |
|7 |    │ └─TABLE FULL SCAN            |n2  |17      |3           |
|8 |    └─HASH JOIN                    |    |922     |1558        |
|9 |      ├─NESTED-LOOP JOIN CARTESIAN |    |3383    |92          |
|10|      │ ├─TABLE FULL SCAN          |r   |199     |1           |
|11|      │ └─MATERIAL                 |    |17      |5           |
|12|      │   └─TABLE FULL SCAN        |n   |17      |3           |
|13|      └─TABLE FULL SCAN            |e   |5       |3           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([r.mgr = e.EMPno], [cast(n.empno, DECIMAL(-1, -1)) = e.MGR]), other_conds(nil)
  9 - output([r.empno], [r.mgr], [r.iters], [r.sal], [n.empno]), filter(nil), rowset=256
      conds(nil), nl_params_(nil), use_batch=false
 10 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 11 - output([n.empno]), filter(nil), rowset=256
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, emp1 n, disemp e
  WHERE r.mgr = e.empno and n.empno = e.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 16:
## - recursive with RECURSIVE Query: Join Skew handling. No local filter
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |433     |30          |
|1 |└─RECURSIVE UNION ALL|    |433     |29          |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |432     |26          |
|4 |    ├─TABLE FULL SCAN|e   |14      |3           |
|5 |    └─TABLE FULL SCAN|r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 17:
## - recursive with RECURSIVE Query: Join Skew handling with RECURSIVE an additional local filter
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr and e.empno < e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SUBPLAN SCAN         |rw  |255     |27          |
|1 |└─RECURSIVE UNION ALL|    |255     |27          |
|2 |  ├─TABLE FULL SCAN  |e   |1       |3           |
|3 |  └─HASH JOIN        |    |254     |24          |
|4 |    ├─TABLE FULL SCAN|e   |5       |3           |
|5 |    └─TABLE FULL SCAN|r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.EMPno], [e.ENAME]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.ENAME]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr and e.empno < e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
+--------+-------+------+

##############################
##   section 4  额外添加recursive member变化
##############################
create table t1(c1 int, c2 int, c3 int);
insert into t1 values(1, 2, 3);
insert into t1 values(4, 5, 6);
insert into t1 values(7, 8, 9);
insert into t1 values(10, 11, 12);
insert into t1 values(13, 14, 15);
insert into t1 values(16, 17, 18);
insert into t1 values(19, 20, 21);

create table disemp1 (
  EMPno  number,
  ENAME varchar(30),
  JOB varchar(30),
  MGR number(4),
  HIREDATE date,
  SAL number(7,2),
  COMM number(7,2),
  DEPTNO number(2)
);

INSERT INTO disemp1 values (7369,'SMITH','CLERK',7902,    str_to_date('1980-11-17','%Y-%m-%d'),800,NULL, 20) ;
INSERT INTO disemp1 VALUES (7499, 'ALLEN','SALESMAN',7698,str_to_date('1981-01-20','%Y-%m-%d'),1600,300,30) ;
INSERT INTO disemp1 VALUES (7521,'WARD','SALESMAN',7698,  str_to_date('1981-01-22','%Y-%m-%d'),1250, 500, 30) ;
INSERT INTO disemp1 VALUES (7566,'JONES','MANAGER',7839,  str_to_date('1981-04-02','%Y-%m-%d'), 2975, NULL, 20) ;
INSERT INTO disemp1 VALUES (7654,'MARTIN','SALESMAN', 7698, str_to_date('1981-09-28','%Y-%m-%d'), 1250, 1400, 30) ;
INSERT INTO disemp1 VALUES (7698, 'BLAKE','MANAGER', 7839,  str_to_date('1981-03-01','%Y-%m-%d'), 2850, NULL, 30) ;
INSERT INTO disemp1 VALUES (7782, 'CLARK','MANAGER', 7839,  str_to_date('1981-06-09','%Y-%m-%d'), 2450, NULL, 10) ;
insert into disemp1 values (7788,'SCOTT','ANALYST', 7566,   str_to_date('1987-04-19','%Y-%m-%d'), 3000, null, 20) ;
INSERT INTO disemp1 VALUES (7839, 'KING','PRESIDENT', NULL, str_to_date('1981-11-17','%Y-%m-%d'), 5000, NULL, 10) ;
INSERT INTO disemp1 VALUES (7844, 'TURNER','SALESMAN', 7698, str_to_date('1981-09-08','%Y-%m-%d'), 1500, 0, 30) ;
INSERT INTO disemp1 VALUES (7876, 'ADAMS','CLERK', 7788,     str_to_date('1987-05-23','%Y-%m-%d'), 1100, NULL, 20) ;
INSERT INTO disemp1 VALUES (7900, 'JAMES', 'CLEARK', 7698,   str_to_date('1981-11-03','%Y-%m-%d'), 950, NULL, 30) ;
INSERT INTO disemp1 VALUES (7902, 'FORD','ANALYST',7566,     str_to_date('1981-11-03','%Y-%m-%d'), 3000, NULL, 20) ;
INSERT INTO disemp1 VALUES (7934,'MILLER','CLERK', 7782,     str_to_date('1982-01-23','%Y-%m-%d'), 1300,NULL, 10) ;

##   这个case 测试了subplan filter
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno = e.mgr and e.empno > some (select c1 from t1 group by c1)
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
==============================================================
|ID|OPERATOR                     |NAME |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |SORT                         |     |1126    |822         |
|1 |└─SUBPLAN SCAN               |rw   |1126    |474         |
|2 |  └─RECURSIVE UNION ALL      |     |1126    |471         |
|3 |    ├─HASH JOIN              |     |79      |16          |
|4 |    │ ├─HASH JOIN            |     |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN    |e    |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN    |n1   |17      |3           |
|7 |    │ └─TABLE FULL SCAN      |n2   |17      |3           |
|8 |    └─NESTED-LOOP SEMI JOIN  |     |1048    |453         |
|9 |      ├─HASH JOIN            |     |3142    |39          |
|10|      │ │ MATERIAL           |     |16      |14          |
|11|      │ └─│ HASH JOIN        |     |16      |10          |
|12|      │   │ ├─TABLE FULL SCAN|n    |17      |3           |
|13|      │   │ └─TABLE FULL SCAN|e    |1       |3           |
|14|      │   TABLE FULL SCAN    |r    |199     |1           |
|15|      └─MATERIAL             |     |7       |4           |
|16|        └─SUBPLAN SCAN       |VIEW1|7       |4           |
|17|          └─HASH GROUP BY    |     |7       |4           |
|18|            └─TABLE FULL SCAN|t1   |7       |2           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      conds([e.EMPno > VIEW1.c1]), nl_params_(nil), use_batch=false
  9 - output([r.empno], [e.MGR], [e.EMPno], [e.SAL], [r.iters], [r.sal]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
 10 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
 11 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
      equal_conds([cast(n.empno, DECIMAL(-1, -1)) = e.MGR]), other_conds(nil)
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno = e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 14 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 15 - output([VIEW1.c1]), filter(nil), rowset=256
 16 - output([VIEW1.c1]), filter(nil), rowset=256
      access([VIEW1.c1])
 17 - output([cast(t1.c1, DECIMAL(11, 0))]), filter(nil), rowset=256
      group([t1.c1]), agg_func(nil)
 18 - output([t1.c1]), filter(nil), rowset=256
      access([t1.c1]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno = e.mgr and e.empno > some (select c1 from t1 group by c1)
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno = e.mgr and e.empno > some (select c1 from t1 group by c1) and e.empno in (select e.empno from disemp1)
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
======================================================================
|ID|OPERATOR                           |NAME   |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------
|0 |SORT                               |       |1126    |911         |
|1 |└─SUBPLAN SCAN                     |rw     |1126    |563         |
|2 |  └─RECURSIVE UNION ALL            |       |1126    |560         |
|3 |    ├─HASH JOIN                    |       |79      |16          |
|4 |    │ ├─HASH JOIN                  |       |17      |8           |
|5 |    │ │ ├─TABLE FULL SCAN          |e      |5       |3           |
|6 |    │ │ └─TABLE FULL SCAN          |n1     |17      |3           |
|7 |    │ └─TABLE FULL SCAN            |n2     |17      |3           |
|8 |    └─NESTED-LOOP SEMI JOIN        |       |1048    |542         |
|9 |      ├─NESTED-LOOP JOIN CARTESIAN |       |3142    |128         |
|10|      │ ├─HASH JOIN                |       |3142    |39          |
|11|      │ │ │ MATERIAL               |       |16      |14          |
|12|      │ │ └─│ HASH JOIN            |       |16      |10          |
|13|      │ │   │ ├─TABLE FULL SCAN    |n      |17      |3           |
|14|      │ │   │ └─TABLE FULL SCAN    |e      |1       |3           |
|15|      │ │   TABLE FULL SCAN        |r      |199     |1           |
|16|      │ └─MATERIAL                 |       |1       |2           |
|17|      │   └─SUBPLAN SCAN           |VIEW2  |1       |2           |
|18|      │     └─TABLE FULL SCAN      |disemp1|1       |2           |
|19|      └─MATERIAL                   |       |7       |4           |
|20|        └─SUBPLAN SCAN             |VIEW1  |7       |4           |
|21|          └─HASH GROUP BY          |       |7       |4           |
|22|            └─TABLE FULL SCAN      |t1     |7       |2           |
======================================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      conds([e.EMPno > VIEW1.c1]), nl_params_(nil), use_batch=false
  9 - output([r.empno], [e.MGR], [e.EMPno], [e.SAL], [r.iters], [r.sal]), filter(nil), rowset=256
      conds(nil), nl_params_(nil), use_batch=false
 10 - output([r.empno], [e.MGR], [e.EMPno], [e.SAL], [r.iters], [r.sal]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
 11 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
 12 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
      equal_conds([cast(n.empno, DECIMAL(-1, -1)) = e.MGR]), other_conds(nil)
 13 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 14 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno = e.MGR], [e.EMPno = e.EMPno]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 15 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 16 - output(nil), filter(nil), rowset=256
 17 - output(nil), filter(nil), rowset=256
      access(nil)
 18 - output([1]), filter(nil), rowset=256
      access(nil), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false,
      range_key([disemp1.__pk_increment]), range(MIN ; MAX)always true
 19 - output([VIEW1.c1]), filter(nil), rowset=256
 20 - output([VIEW1.c1]), filter(nil), rowset=256
      access([VIEW1.c1])
 21 - output([cast(t1.c1, DECIMAL(11, 0))]), filter(nil), rowset=256
      group([t1.c1]), agg_func(nil)
 22 - output([t1.c1]), filter(nil), rowset=256
      access([t1.c1]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno = e.mgr and e.empno > some (select c1 from t1 group by c1) and e.empno in (select e.empno from disemp1)
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

drop database cte_st;
